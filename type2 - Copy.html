n     wcc<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vishnu Gesture - Dual Hand System</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        
        /* HUD Styling */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #heading {
            position: absolute;
            top: 20px; width: 100%;
            text-align: center;
            color: #ffcc00;
            font-size: 4rem;
            font-weight: 900;
            text-shadow: 0 0 30px rgba(255, 204, 0, 0.6);
            letter-spacing: 10px;
            font-family: 'Cinzel', serif; /* Divine look */
            text-transform: uppercase;
        }

        #status-bar {
            position: absolute;
            top: 100px; width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-size: 1.2rem;
        }

        #controls-hint {
            position: absolute;
            bottom: 30px; left: 30px;
            color: rgba(0, 255, 255, 0.7);
            font-size: 1rem;
            line-height: 1.6;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-left: 4px solid #00ffff;
            border-radius: 5px;
        }

        #video-preview {
            position: absolute;
            bottom: 30px; right: 30px;
            width: 200px; height: 150px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            overflow: hidden;
            transform: scaleX(-1); /* Mirror */
        }

        video { width: 100%; height: 100%; object-fit: cover; }
        
        #shape-name {
            font-weight: bold;
            color: #00ffff;
        }
        
        .active-hand { color: #00ff00; }
        .inactive-hand { color: #ff0000; }
    </style>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="ui-layer">
        <div id="heading">VISHNU GESTURE</div>
        <div id="status-bar">
            Current Form: <span id="shape-name">GALAXY</span> | 
            Hands: <span id="hand-status" class="inactive-hand">SEARCHING...</span>
        </div>
        <div id="controls-hint">
            <b>1 HAND:</b> Position & Rotate<br>
            <b>2 HANDS:</b> Pull apart to EXPAND universe<br>
            <b>ðŸ‘Œ PINCH:</b> Cycle Shape (Heart, Flower, etc)<br>
            <b>âœŠ FIST:</b> Black Hole Gravity
        </div>
    </div>

    <div id="video-preview">
        <video id="input_video"></video>
    </div>

<script>
    // ================= CONFIGURATION =================
    const CONFIG = {
        particleCount: 8000,
        handSmoothing: 0.15, // Lower = smoother but more lag
        pinchThreshold: 0.04,
        fistThreshold: 0.18, // Average finger dist to palm
        shapeSwitchCooldown: 1500 // ms
    };

    // ================= THREE.JS SETUP =================
    const scene = new THREE.Scene();
    // Deep space fog
    scene.fog = new THREE.FogExp2(0x000000, 0.001);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 60;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // ================= PARTICLE SYSTEM =================
    
    // Texture Generation (Glowing Star)
    function createSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(32,32,0,32,32,32);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
        grad.addColorStop(0.2, 'rgba(240, 240, 255, 0.6)');
        grad.addColorStop(0.5, 'rgba(0, 100, 255, 0.2)');
        grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0,64,64);
        return new THREE.CanvasTexture(canvas);
    }

    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const targetPositions = new Float32Array(CONFIG.particleCount * 3);
    const velocities = new Float32Array(CONFIG.particleCount * 3); // For physics
    const colors = new Float32Array(CONFIG.particleCount * 3);
    
    // Initialize
    const colorObj = new THREE.Color();
    for(let i=0; i<CONFIG.particleCount; i++) {
        positions[i*3] = (Math.random()-0.5)*100;
        positions[i*3+1] = (Math.random()-0.5)*100;
        positions[i*3+2] = (Math.random()-0.5)*100;
        velocities[i*3] = 0; velocities[i*3+1] = 0; velocities[i*3+2] = 0;
        
        colorObj.setHSL(Math.random(), 0.7, 0.5);
        colors[i*3] = colorObj.r;
        colors[i*3+1] = colorObj.g;
        colors[i*3+2] = colorObj.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const material = new THREE.PointsMaterial({
        size: 0.6,
        map: createSprite(),
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true
    });

    const particleSystem = new THREE.Points(geometry, material);
    scene.add(particleSystem);

    // ================= SHAPE LOGIC =================
    
    const shapes = [
        { name: "GALAXY", func: (i) => {
            const angle = Math.random() * Math.PI * 2;
            const r = Math.random() * 30; // Disk radius
            const spiral = 2; 
            return [
                (r * Math.cos(angle + r/spiral)),
                ((Math.random()-0.5) * (r*0.2)), // Flat disk
                (r * Math.sin(angle + r/spiral))
            ];
        }, color: [0.6, 0.8, 0.5] }, // Blue/Purple

        { name: "HEART", func: (i) => {
            const t = Math.random() * Math.PI * 2;
            const p = Math.random() * Math.PI;
            const x = 16 * Math.pow(Math.sin(p), 3) * Math.cos(t);
            const y = 13 * Math.cos(p) - 5 * Math.cos(2*p) - 2 * Math.cos(3*p) - Math.cos(4*p);
            const z = 16 * Math.pow(Math.sin(p), 3) * Math.sin(t);
            return [x, y, z];
        }, color: [0.95, 1.0, 0.5] }, // Red

        { name: "FLOWER", func: (i) => {
             const u = Math.random() * Math.PI * 4; 
             const v = Math.random() * Math.PI;
             const r = 15 + 5 * Math.cos(5 * u) * Math.sin(v);
             return [
                 r * Math.sin(v) * Math.cos(u),
                 r * Math.sin(v) * Math.sin(u),
                 r * Math.cos(v)
             ];
        }, color: [0.8, 1.0, 0.6] }, // Pink

        { name: "SATURN", func: (i) => {
            if(Math.random() > 0.3) {
                // Sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 10;
                return [r*Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi)];
            } else {
                // Ring
                const ang = Math.random() * Math.PI * 2;
                const rad = 15 + Math.random() * 10;
                return [Math.cos(ang)*rad, (Math.random()-0.5), Math.sin(ang)*rad];
            }
        }, color: [0.1, 1.0, 0.6] }, // Gold

        { name: "DNA HELIX", func: (i) => {
            const t = i * 0.1;
            const radius = 10;
            const height = (i % 100) - 50;
            const offset = (i % 2 === 0) ? 0 : Math.PI;
            return [
                Math.cos(t + offset) * radius,
                height,
                Math.sin(t + offset) * radius
            ];
        }, color: [0.3, 1.0, 0.6] } // Green
    ];

    let currentShapeIndex = 0;
    
    function updateTargets() {
        const shape = shapes[currentShapeIndex];
        document.getElementById('shape-name').innerText = shape.name;
        
        const targetC = new THREE.Color().setHSL(shape.color[0], shape.color[1], shape.color[2]);

        for(let i=0; i<CONFIG.particleCount; i++) {
            const pos = shape.func(i);
            targetPositions[i*3] = pos[0];
            targetPositions[i*3+1] = pos[1];
            targetPositions[i*3+2] = pos[2];

            // Update colors slowly in animation loop, but set target here if we wanted
            // For now let's just shift immediate for simplicity
            colors[i*3] = targetC.r + (Math.random()-0.5)*0.1;
            colors[i*3+1] = targetC.g + (Math.random()-0.5)*0.1;
            colors[i*3+2] = targetC.b + (Math.random()-0.5)*0.1;
        }
        geometry.attributes.color.needsUpdate = true;
    }
    
    updateTargets(); // Initial call

    // ================= HAND TRACKING STATE =================
    const inputState = {
        hasHands: false,
        handCount: 0,
        center: new THREE.Vector3(0,0,0), // Center between hands
        distance: 1, // Distance between hands (1 = neutral)
        isPinching: false,
        isFist: false,
        lastShapeSwitch: 0
    };

    // Smooth Variables
    const smoothCenter = new THREE.Vector3(0,0,0);
    let smoothDist = 0;

    // MediaPipe Setup
    const videoElement = document.getElementById('input_video');
    
    function calculateHandState(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            inputState.hasHands = false;
            inputState.handCount = 0;
            document.getElementById('hand-status').innerText = "SEARCHING...";
            document.getElementById('hand-status').className = "inactive-hand";
            return;
        }

        inputState.hasHands = true;
        inputState.handCount = results.multiHandLandmarks.length;
        document.getElementById('hand-status').innerText = `${inputState.handCount} HAND(S) ACTIVE`;
        document.getElementById('hand-status').className = "active-hand";

        // --- POSITION CALCULATION ---
        const h1 = results.multiHandLandmarks[0];
        const h2 = results.multiHandLandmarks[1]; // Might be undefined

        // Helper: Convert normalized (0-1) to World (-50 to 50)
        const toWorld = (lm) => new THREE.Vector3((0.5 - lm.x)*120, (0.5 - lm.y)*80, 0);

        const pos1 = toWorld(h1[9]); // Middle finger knuckle (stable center)
        
        if (h2) {
            // TWO HANDS
            const pos2 = toWorld(h2[9]);
            
            // Center is midpoint
            inputState.center.copy(pos1).add(pos2).multiplyScalar(0.5);
            
            // Distance determines scale (Expansion)
            // Base distance approx 30 units, we map ratio
            const dist = pos1.distanceTo(pos2);
            inputState.distance = Math.max(0.2, dist / 30); // 30 is arbitrary "neutral" distance
        } else {
            // ONE HAND
            inputState.center.copy(pos1);
            inputState.distance = 1.0; // Reset scale
        }

        // --- GESTURE RECOGNITION (Using Hand 1 primarily for trigger) ---
        
        // 1. PINCH (Thumb tip vs Index tip)
        const pinchDist = Math.hypot(h1[8].x - h1[4].x, h1[8].y - h1[4].y);
        const isPinchingNow = pinchDist < CONFIG.pinchThreshold;
        
        if (isPinchingNow && !inputState.isPinching) {
            // Rising edge (Just started pinching)
            const now = Date.now();
            if (now - inputState.lastShapeSwitch > CONFIG.shapeSwitchCooldown) {
                currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
                updateTargets();
                inputState.lastShapeSwitch = now;
            }
        }
        inputState.isPinching = isPinchingNow;

        // 2. FIST (Fingertips vs Palm base)
        // Average dist of tips (8,12,16,20) to wrist(0) or palm center(9)
        // Simplified: Check if bounding box of fingers is small
        // Better: Check index tip(8) to wrist(0) dist? 
        // Let's use Index Tip (8) to Wrist (0) distance comparison. 
        // Open hand: dist is large (~0.4). Fist: dist is small (~0.15).
        const tipToWrist = Math.hypot(h1[8].x - h1[0].x, h1[8].y - h1[0].y);
        inputState.isFist = tipToWrist < CONFIG.fistThreshold;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 2, // Enable Dual Hands
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(calculateHandState);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // ================= ANIMATION & PHYSICS LOOP =================
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        // 1. Smooth the Hand Inputs (Lerp)
        if (inputState.hasHands) {
            smoothCenter.lerp(inputState.center, CONFIG.handSmoothing);
            smoothDist += (inputState.distance - smoothDist) * CONFIG.handSmoothing;
        } else {
            // Return to center if no hands
            smoothCenter.lerp(new THREE.Vector3(0,0,0), 0.05);
            smoothDist += (1.0 - smoothDist) * 0.05;
        }

        const posAttr = geometry.attributes.position.array;

        // 2. Particle Physics
        for (let i = 0; i < CONFIG.particleCount; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // Current Pos
            const cx = posAttr[ix];
            const cy = posAttr[iy];
            const cz = posAttr[iz];

            // Base Target Pos (From Shape)
            let tx = targetPositions[ix];
            let ty = targetPositions[iy];
            let tz = targetPositions[iz];

            // A. Apply Expansion (Based on Two-Hand stretch)
            // Expand relative to origin (0,0,0) before translation
            tx *= smoothDist;
            ty *= smoothDist;
            tz *= smoothDist;

            // B. Apply Hand Translation (Move whole shape to hand center)
            tx += smoothCenter.x;
            ty += smoothCenter.y;
            tz += smoothCenter.z;

            // C. Black Hole Effect (Fist)
            if (inputState.isFist) {
                // Ignore shape, suck into hand center
                tx = smoothCenter.x;
                ty = smoothCenter.y;
                tz = smoothCenter.z;
            }

            // D. Physics Integration (Spring/Damper)
            // Force vector to target
            const dx = tx - cx;
            const dy = ty - cy;
            const dz = tz - cz;

            // Physics params
            const speed = inputState.isFist ? 8.0 : 3.0; // Fast collapse if fist
            const damping = 0.92;

            velocities[ix] += dx * speed * dt;
            velocities[iy] += dy * speed * dt;
            velocities[iz] += dz * speed * dt;

            // Friction
            velocities[ix] *= damping;
            velocities[iy] *= damping;
            velocities[iz] *= damping;

            // Add some noise/life
            velocities[ix] += Math.sin(time + iy) * 0.05;
            velocities[iy] += Math.cos(time + ix) * 0.05;

            // Update Position
            posAttr[ix] += velocities[ix] * dt;
            posAttr[iy] += velocities[iy] * dt;
            posAttr[iz] += velocities[iz] * dt;
        }

        geometry.attributes.position.needsUpdate = true;
        
        // Gentle rotation of the whole container for dynamism
        scene.rotation.y = time * 0.05;
        // Tilt slightly based on hand Y position
        scene.rotation.x = -smoothCenter.y * 0.005;

        renderer.render(scene, camera);
    }

    animate();

    // Responsive
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>